\section{Conclusion}
In this paper we have explored the various aspects of specifying and implementing network protocols. We have discussed their importance and the difficulties revolved around creating a correct implementation. We have argued that creating a DSL for implementing protocols would be beneficial in managing this complexity.

Our DSL provides a natural way for specifying protocols that help us reason about how one should create implementations. Further we can use this specification to verify that we obey the protocol during run-time. We have showed that the errors generated from the run-time checks provide us with enough information to pin-point exactly what and where something goes wrong. We have also seen that most of the benefits of our DSL relies on its correct usage. This means that developers must dedicate time to specify the message flow of the protocol and create validators for these messages. We have also stated that the Validators must be correct in order for the Protocol Monitor to function. To alleviate this problem we have ensured that testing a validator is a straightforward process.

The usefulness of our DSL has been proven by our implementation of a chat server. This server allows multiple participants to connect and initiate a Diffie-Hellman-Merkel key exchange to establish a secure communication channel to both the server and all connecting clients. Allowing chat participants to exchange messages that only the recipient and sender can decrypt. We have also verified that the actual data being transmitted over the network is encrypted and in the order we have specified. We have also seen that the system is capable of handling a large amount users simultaneously generating requests that must be responded.

The overhead of our solution has been calculated to be around 20\%. A reasonable penalty to be paid for enabling run-time checks. The DSL does still provide its usefulness when performance is the main priority of a system. In these situations we can use the DSL to test a system, not run it. This way we can enable run-time checks on a system while still having the freedom to create the system however desired.

We believe that our solution provides an excellent base for development and implementation of network protocols. It provides a clear advantage in that it also helps create the actual implementation of the protocol, unlike a model checker. It does however not solve all the issues involved with the correct implementation of a protocol. We have examined the case of Apple's Goto bug and seen that it is not a single tool that can solve all problems. Development teams must focus on implementing what are regarded as best practices in software development. Practices such as peer review, testing and coding standards must be in place to help ensure successful implementations. 


\subsection{Future Work}
This paper contains many topics that are worth exploring further. Over the course of this dissertation, we have implemented various protocols and gained a lot of valuable knowledge. Our DSL has seen many changes and new features have been added at an almost consistent pace to solve the problems encountered when implementing new protocols.

Areas that are worth looking into are expanding the DSL to make it more natural when defining validators. The validators are still mostly mostly plain Scala code and use no features of Scala to make it look more like natural language. A great starting point would be to look at the testing framework that we have used to create our own tests, ScalaTest\footnote{\href{http://scalatest.org/}{ScalaTest.org}}. ScalaTest provides a syntax for specifying test cases in a natural language. A test is in reality what a Validators does when it validates an input, so there should be a lot of insight that can be gained from exploring this DSL.

To easier allow for implementing change and allowing new features to be added, our system is not performing to its max potential. It is still in a ``change-friendly'' state where we can make changes without to many consequences. Mainly the state manipulation of the protocol state should be able to perform faster. It would also be interesting to implement the ``Protocol State'' as an actor. In certain cases it should increase performance as well as provide the possibility for additional features.

%After specifying a protocol in our DSL, it would be of great use to be able to generate a model that showed the communication pattern between the participants in the protocol.

%Ideally our DSL would have some form of compile time checks that could check if a consumer had implemented cases for the messages returned from the validators. The compile time errors would then tell us which cases we had not implemented in our consumers. This may not be possible due to the complex nature of the protocol implementation, but is worth researching.


%If given more time we would want to expand our DSL to be able to better monitor the communication over the event bus. Preferably we would want to create a solution where a Protocol Monitor was attached to the event bus, ensuring all communication was regulated by a PM. An alternative approach could be to not rely on the event bus, but allowing the PM to maintain multiple connections, avoiding the need for using the event bus. This may require a complete rework of the DSL, but may be well worth the effort.

